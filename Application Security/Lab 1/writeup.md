# Bugs

Within part 2 of the assignment, I located three bugs within the *giftcardreader.c* code. While the first two bugs reported cause a crash, the third and final causes the program to hang indefinately. While the assignment instructions request that the two crash case be caused by *crash1.gft* and *crash2.gft* gift card files respectively, I identified the first crash without the use of a gft file (see below). Each vulnerability case, its cause, how it was located, and its fix are outlined below. All line numbers references in the follwoing write-up correspond to the original *giftcardreader.c* file.

### Crash 1 - Invalid arguments provided
As mentioned above, the first crash case does not require a malicious gift card file, instead it is the result of a poor argument handling implementation. The reader's main function, beginning on line 262, takes two parameters provided to the compiled program from the command line when the program is started: "int argc" and "char **argv." argc is an integer representing the number of arguments provided by the user. argv is an array of pointers to character objects, or null-terminated strings. In the case of the intended use of the reader, argc is 3 - noting the 3 arguments, argv[0] is a pointer to the string "./giftcardreader" - the compiled program, argv[1] is a pointer to the string "1" or "2" - to indicate json format or not, and argv[2] is a pointer to the string "examplefile.gft" - the gift card file. The next line of actual code, line 264, then attempts to open a file with the name of argv[2], in our example case, examplefile.gft - "FILE *input_fd = fopen(argv[2],"r")." Without the proper number of arguments, specifically a number 1 or two to indicate json followed by the name of an existing file in the directory, this action will fail to open and assign a file to the input_fd pointer. Such a fail will then cause a segmentation fault when the next line, line 265, attempts to execute - "thisone = gift_card_reader(input_fd)."
	
To ultimately fix this crash, the program must be prepared for the user to provide an incorrect argument format. To do so, I implemented a check that a) there is the poper number of arguments - 3, and b) the gift card file provided as argv[2] is a file that exists within the directory. Immediately after the input_fd pointer is created, I include the following check: "if (argc < 3 || !(input_fd))." If these conditions are met, the arguments were not provided correctly and several lines of text are printed to the user's terminal explaining how to provide arguments correctly in a -h/-help style ouput, as well as terminating the executing program. Incorrect arguments examples include the following **./giftcardreader.c 1 gfNotInTheDirectory.gft**, **./giftcardreader.c**, **./giftcardreader.c examplefile.gft**, **./giftcardreader.c 1**, etc.

### Crash 2 - Negative number for gift card "num_bytes" variable
The second crash I discovered was caused using the *crash2.gft* gift card file included as part of this submission. This *crash2.gft* file was created using the provided *giftcardexamplewriter.c* with some minor tweaks. For startes, the obvious, the writer was changed to write to the *crash2.gft* file. Second, the change that actually causes the crash when the gift card is fed to the reader, line 25: "examplegc.num_bytes = -1." This test case uses -1, but the behavior appears remain the same for all negative numbers. After this gift card is created with the described edits to the writer and provided as an argument for the reader, the reader recieves a segmentation fault upon reaching line 190: fread(ptr, ret_val->num_bytes, 1, input_fd);. To understand why this instruction causes a segmentation fault, we must first examine the instruction that proceeds it on line 189: ptr = malloc(ret_val->num_bytes);. Because our crash2.gft file included -1 as the num_bytes variable, malloc is called with -1. This causes ptr to point to the address 0x0, as discovered using the GNU Debugger (gdb) with the command "p ptr" upon reaching the fread instruction on line 190. This is not a valid readable address for this executing program, so when fread attempts to read from this address, it causes a segmentation fault.

To fix this bug, I included a check just before the ptr variable assignment currently on line 189. The if statement checks to see if the provided gift card file reports a "num_bytes" value less than 0 - "if (ret_val->num_bytes < 0)." If this variable is in fact less than 0, I include two printf statements that write to the terminal that the gift card provided is invalid, and that the num_bytes variable must be greater than or equal to 0, as well as terminating the executing program.
 
### Hang - Using unsanitized input to execute negative addition to cause an infinite while loop
The hang case that I discovered is ultimately caused by the mysterious cast of user input (data within the gift card file) from an unsigned char to a  char. On line 23 of the reader, the program begins to execute a while loop, specifically a while(1) loop. "Always true" loop conditions are best to be avoided in general, but the intention in this case is to increase the value of the pc variable with each iteration of the loop. This increase will eventually satisfy the conditions of an if statement within the loop, found on line 63: "if (pc > program+256) break." Once its condition is satisfied, the program is able to escape. Unfortunately, within this while loop exists a switch statement, where in the case of the pointer *pc being 0x09, user provided input is able to edit this pc value used to escape the loop. Further, this input that is originally assigned to be of the type unsigned char is cast to a char, or "signed char." In short, this allows input that is originally read into the program to only represent positive numbers in terms of arithmetic, can now be interpreted as positive or negative numbers. Specifically, on line 56, in the switch case in which *pc is 0x09, this newly cast to char variable arg1 is added to the value of the pc variable, so in the case of a negative arg1, it is subtracted. When a gift card is created to enter this 0x09 case with arg1 set to -6, the program becomes trapped in an infinite loop of the 0x00 - no op case and the 0x09 - pc-subtraction case. The exact gift card I used to cause this hang has the following value set for examplegcp.program: "(char*)0x00fa09000000."

To defend the reader from this hang scenario, I removed the unecessary cast of the arg1 variable to the char type in the 0x09 case of the switch statement. This cast has been removed from line 56, the source of this exact hang condition. By removing this cast, users are unable to input negative values for the arg1 variable that results in negative addition within the 0x09 case, and thus avoid the hang scenario described above.

# Testing

Our existing coverage of the *giftcardreader.c* program as reported by lcov was 54.6%. This includes my existing test suite as of completing part 2 of the assignment, the 54.6% reflects the following test cases: crash1, *crash2.gft*, and *hang.gft*. To increase coverage, we examined the html file included with the lcov output that showed which lines of the program are not yet being covered by the test suite. This led me to create *cov1.gft* and *cov2.gft*.

### cov1.gft
The first gift card file to imporve coverage, *cov1.gft*, is a simple amount change case, similar to the *examplefile.gft* that was provided in the instructions, but is not part of our test suite. The command executed: **./giftcardreader 1 cov1.gft**. This new test case increased our line coverage from 54.6% to 60.9% (95/174 to 106/174 lines covered).

### cov2.gft
The second gift card file to improve coverage, *cov2.gft*, is still a simple amount change case, but the argument "2" is provided to print the gift card information in the json format. The command executed: **./gcrcrash 2 cov2.gft**. This second test case increased our line coverage from 60.9% to 73.6% (106/174 to 128/174 lines). This test case also got the test suite's function coverage to 100% (5/6).

## American Fuzzy Lop Fuzzer
After running the AFL fuzzer on the compiled reader for just under 3 hours, the fuzzer provided 26 additional hang cases, 44 additional crash cases, and 152 additional test cases, these numbers were reduced after deploying the afl-cmin tool. Running these new test cases against the reader improved our line coverage from 73.6% (128/174) to 79.3% (138/174). Two of the crashes/hangs reported by AFL are detailed and patched below.

### Fuzzer 1 (Crash) - 0x03 instruction allowed to keep growing *mptr
AFL identified a crash case, *fuzzer1.gft*, in which a segmentation fault occurs, stating that the main function attempted to run with the following parameters: argc = -2123776, argv = 0xffde500000000000. Here, it appears that the root of the issue is within the animate function. Specifically, the animate function is provided the parameter "program" that in the case of this gift card, is just \003 repeated many times. This results in a constant repeating of the "0x03" case within the switch statement. This "0x03" case has the following instuction: "mptr += regs[arg1]." The cursor (mptr) is being moved by the regs[arg1] value repeatedly. If allowed to continue unchecked, I believe the contents of mptr is growing beyond its original intended size and writing over other values in memory - something of a buffer overflow.

To fix this crash, I removed the "while(1)" loop and instead replaced it with a "while(i < 43)" loop. The interger i, already declared in the existing code, is now incremented by 1 after each execution of the loop. As mentioned above, my understanding is that the "always true" "while(1)" loop is bad programming practice, but I specifically chose the number 43 because of the predefined nature of the "program" variable in the giftcard.h file. The giftcard.h file lists the program variable as a pointer to an unsigned char of 128 bytes. Further, giftcard.h reports that each program instruction is 3 bytes: 1 byte (opcode), 1 byte (arg1), and 1 byte (arg2). Meaning, a properly formatted gift card file should only contain ~43 instuctions for a total of 128 bytes. Each iteration of the loop utilizes 3 bytes of the program variable, so 43 iterations should process the entirety of a "valid" gift card program as well as avoiding hangs caused by a "while(1)" loop.

### Fuzzer 2 (Crash) - animate function editing or erasing memory containing existing variables
The second fuzzer case that I will be reported on is another crash case, *fuzzer2.gft*. The program appears to be behaving normally, but when it reaches line 162: "gcrd_ptr = (struct gift_card_record_data *) gcd_ptr->gift_card_record_data[i]," it crashes. After stepping through the compiled program in gdb several times with the *fuzzer2.gft* file set as the input gift card, I found that the value, or rather the address, of "thisone->gift_card_data," the variable that is being referenced to create "gcd_ptr->gift_card_data" is set to "0x0" - the address 0, after the animate function is run and returns. Before the animate function is called on line 98, gdb reports that the "thisone" variable points to a legitimate/accessible address (e.g. "thisone->gift_card_data = (void *) 0x55555555a4b0"). However, after returning from the animate function, gdb reports that it now points to the null pointer address of "0x0." Thus, when the program attempts to read from the memory address pointed to by this variable, it recieves a segmentation fault because it is unable to actually read anything from that address. This must mean at some point within the animate function, the program is writing to memory outside of the bounds of the intended variable.

To fix this crash, I chose to identify the total value of the gift card and store it in a variable before the animate function is called because printing the total value of the gift card is the only operation taking place after that animate function that requires the gift_card_data to be intact. This means adding the instruction "int total_value = get_gift_card_value(thisone)" early in the "print_gift_card_info()" function on line 74. Further, line 101: "printf("  Total value: %d\n\n",get_gift_card_value(thisone))" must be changed to: "printf("  Total value: %d\n\n", total_value)." The total value of the gift card calculated by calling the "get_gift_card_value" function and is stored as an integer to be used later by the print statement, without being depending on the animate function's manipulation of memory.
