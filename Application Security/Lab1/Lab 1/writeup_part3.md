# Testing

Our existing coverage of the *giftcardreader.c* program as reported by lcov was 54.6%. This includes my existing test suite as of completing part 2 of the assignment, the 54.6% reflects the following test cases: crash1, *crash2.gft*, and *hang.gft*. To increase coverage, we examined the html file included with the lcov output that showed which lines of the program are not yet being covered by the test suite. This led me to create *cov1.gft* and *cov2.gft*.

### cov1.gft
The first gift card file to imporve coverage, *cov1.gft*, is a simple amount change case, similar to the *examplefile.gft* that was provided in the instructions, but is not part of our test suite. The command executed: **./giftcardreader 1 cov1.gft**. This new test case increased our line coverage from 54.6% to 60.9% (95/174 to 106/174 lines covered).

### cov2.gft
The second gift card file to improve coverage, *cov2.gft*, is still a simple amount change case, but the argument "2" is provided to print the gift card information in the json format. The command executed: **./gcrcrash 2 cov2.gft**. This second test case increased our line coverage from 60.9% to 73.6% (106/174 to 128/174 lines). This test case also got the test suite's function coverage to 100% (5/6).

## American Fuzzy Lop Fuzzer
After running the AFL fuzzer on the compiled reader for just under 3 hours, the fuzzer provided 26 additional hang cases, 44 additional crash cases, and 152 additional test cases, these numbers were reduced after deploying the afl-cmin tool. Running these new test cases against the reader improved our line coverage from 73.6% (128/174) to 79.3% (138/174). Two of the crashes/hangs reported by AFL are detailed and patched below.

### Fuzzer 1 (Crash) - 0x03 instruction allowed to keep growing *mptr
AFL identified a crash case in which a segmentation fault occurs, stating that the main function attempted to run with the following parameters: argc = -2123776, argv = 0xffde500000000000 - *fuzzer1.gft*. Here, it appears that the root of the issue is within the animate function. Specifically, the animate function is provided the parameter "program" that in the case of this gift card, is just \003 repeated many times. This results in a constant repeating of the "0x03" case within the switch statement. This "0x03" case has the following instuction: "mptr += regs[arg1]." The cursor (mptr) is being moved by the regs[arg1] value repeatedly. If allowed to continue unchecked, I believe the contents of mptr is growing beyond its original intended size and writing over other values in memory - something of a buffer overflow.

To fix this crash, I removed the "while(1)" loop and instead replaced it with a "while(i < 43)" loop. The interger i, already declared in the existing code, is now incremented by 1 after each execution of the loop. As mentioned above, my understanding is that the "always true" "while(1)" loop is bad programming practice, but I specifically chose the number 43 because of the predefined nature of the "program" variable in the giftcard.h file. The giftcard.h file lists the program variable as a pointer to an unsigned char of 128 bytes. Further, giftcard.h reports that each program instruction is 3 bytes: 1 byte (opcode), 1 byte (arg1), and 1 byte (arg2). Meaning, a properly formatted gift card file should only contain ~43 instuctions for a total of 128 bytes. Each iteration of the loop utilizes 3 bytes of the program variable, so 43 iterations should process the entirety of a "valid" gift card program as well as avoiding hangs caused by a "while(1)" loop.

### Fuzzer 2 (Crash) - animate function editing or erasing memory containing existing variables
The second fuzzer case that I will be reported on is another crash case, *fuzzer2.gft*. The program appears to be behaving normally, but when it reaches line 162: "gcrd_ptr = (struct gift_card_record_data *) gcd_ptr->gift_card_record_data[i]," it crashes. After stepping through the compiled program in gdb several times with the *fuzzer2.gft* file set as the input gift card, I found that the value, or rather the address, of "thisone->gift_card_data," the variable that is being referenced to create "gcd_ptr->gift_card_data" is set to "0x0" - the address 0, after the animate function is run and returns. Before the animate function is called on line 98, gdb reports that the "thisone" variable points to a legitimate/accessible address (e.g. "thisone->gift_card_data = (void *) 0x55555555a4b0"). However, after returning from the animate function, gdb reports that it now points to the null pointer address of "0x0." Thus, when the program attempts to read from the memory address pointed to by this variable, it recieves a segmentation fault because it is unable to actually read anything from that address. This must mean at some point within the animate function, the program is writing to memory outside of the bounds of the intended variable.

To fix this crash, I chose to identify the total value of the gift card and store it in a variable before the animate function is called because printing the total value of the gift card is the only operation taking place after that animate function that requires the gift_card_data to be intact. This means adding the instruction "int total_value = get_gift_card_value(thisone)" early in the "print_gift_card_info()" function on line 74. Further, line 101: "printf("  Total value: %d\n\n",get_gift_card_value(thisone))" must be changed to: "printf("  Total value: %d\n\n", total_value)." The total value of the gift card calculated by calling the "get_gift_card_value" function and is stored as an integer to be used later by the print statement, without being depending on the animate function's manipulation of memory.