# Bugs

Within part 2 of the assignment, I located three bugs within the *giftcardreader.c* code. While the first two bugs reported cause a crash, the third and final causes the program to hang indefinately. While the assignment instructions request that the two crash case be caused by *crash1.gft* and *crash2.gft* gift card files respectively, I identified the first crash without the use of a gft file (see below). Each vulnerability case, its cause, how it was located, and its fix are outlined below. All line numbers references in the follwoing write-up correspond to the original *giftcardreader.c* file.

### Crash 1 - Invalid arguments provided
As mentioned above, the first crash case does not require a malicious gift card file, instead it is the result of a poor argument handling implementation. The reader's main function, beginning on line 262, takes two parameters provided to the compiled program from the command line when the program is started: "int argc" and "char **argv." argc is an integer representing the number of arguments provided by the user. argv is an array of pointers to character objects, or null-terminated strings. In the case of the intended use of the reader, argc is 3 - noting the 3 arguments, argv[0] is a pointer to the string "./giftcardreader" - the compiled program, argv[1] is a pointer to the string "1" or "2" - to indicate json format or not, and argv[2] is a pointer to the string "examplefile.gft" - the gift card file. The next line of actual code, line 264, then attempts to open a file with the name of argv[2], in our example case, examplefile.gft - "FILE *input_fd = fopen(argv[2],"r")." Without the proper number of arguments, specifically a number 1 or two to indicate json followed by the name of an existing file in the directory, this action will fail to open and assign a file to the input_fd pointer. Such a fail will then cause a segmentation fault when the next line, line 265, attempts to execute - "thisone = gift_card_reader(input_fd)."
	
To ultimately fix this crash, the program must be prepared for the user to provide an incorrect argument format. To do so, I implemented a check that a) there is the poper number of arguments - 3, and b) the gift card file provided as argv[2] is a file that exists within the directory. Immediately after the input_fd pointer is created, I include the following check: "if (argc < 3 || !(input_fd))." If these conditions are met, the arguments were not provided correctly and several lines of text are printed to the user's terminal explaining how to provide arguments correctly in a -h/-help style ouput, as well as terminating the executing program. Incorrect arguments examples include the following **./giftcardreader.c 1 gfNotInTheDirectory.gft**, **./giftcardreader.c**, **./giftcardreader.c examplefile.gft**, **./giftcardreader.c 1**, etc.

### Crash 2 - Negative number for gift card "num_bytes" variable
The second crash I discovered was caused using the *crash2.gft* gift card file included as part of this submission. This *crash2.gft* file was created using the provided *giftcardexamplewriter.c* with some minor tweaks. For startes, the obvious, the writer was changed to write to the *crash2.gft* file. Second, the change that actually causes the crash when the gift card is fed to the reader, line 25: "examplegc.num_bytes = -1." This test case uses -1, but the behavior appears remain the same for all negative numbers. After this gift card is created with the described edits to the writer and provided as an argument for the reader, the reader recieves a segmentation fault upon reaching line 190: fread(ptr, ret_val->num_bytes, 1, input_fd);. To understand why this instruction causes a segmentation fault, we must first examine the instruction that proceeds it on line 189: ptr = malloc(ret_val->num_bytes);. Because our crash2.gft file included -1 as the num_bytes variable, malloc is called with -1. This causes ptr to point to the address 0x0, as discovered using the GNU Debugger (gdb) with the command "p ptr" upon reaching the fread instruction on line 190. This is not a valid readable address for this executing program, so when fread attempts to read from this address, it causes a segmentation fault.

To fix this bug, I included a check just before the ptr variable assignment currently on line 189. The if statement checks to see if the provided gift card file reports a "num_bytes" value less than 0 - "if (ret_val->num_bytes < 0)." If this variable is in fact less than 0, I include two printf statements that write to the terminal that the gift card provided is invalid, and that the num_bytes variable must be greater than or equal to 0, as well as terminating the executing program.
 
### Hang - Using unsanitized input to execute negative addition to cause an infinite while loop
The hang case that I discovered is ultimately caused by the mysterious cast of user input (data within the gift card file) from an unsigned char to a  char. On line 23 of the reader, the program begins to execute a while loop, specifically a while(1) loop. "Always true" loop conditions are best to be avoided in general, but the intention in this case is to increase the value of the pc variable with each iteration of the loop. This increase will eventually satisfy the conditions of an if statement within the loop, found on line 63: "if (pc > program+256) break." Once its condition is satisfied, the program is able to escape. Unfortunately, within this while loop exists a switch statement, where in the case of the pointer *pc being 0x09, user provided input is able to edit this pc value used to escape the loop. Further, this input that is originally assigned to be of the type unsigned char is cast to a char, or "signed char." In short, this allows input that is originally read into the program to only represent positive numbers in terms of arithmetic, can now be interpreted as positive or negative numbers. Specifically, on line 56, in the switch case in which *pc is 0x09, this newly cast to char variable arg1 is added to the value of the pc variable, so in the case of a negative arg1, it is subtracted. When a gift card is created to enter this 0x09 case with arg1 set to -6, the program becomes trapped in an infinite loop of the 0x00 - no op case and the 0x09 - pc-subtraction case. The exact gift card I used to cause this hang has the following value set for examplegcp.program: "(char*)0x00fa09000000."

To defend the reader from this hang scenario, I removed the unecessary cast of the arg1 variable to the char type in the 0x09 case of the switch statement. This cast has been removed from line 56, the source of this exact hang condition. By removing this cast, users are unable to input negative values for the arg1 variable that results in negative addition within the 0x09 case, and thus avoid the hang scenario described above.